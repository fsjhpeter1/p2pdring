<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ä¸‰æ¬¡å“¥P2Pç•«æ¿ğŸ”¥</title>
<style>
  body, html { margin:0; padding:0; height:100%; overflow:hidden; background:#222; color:#eee; font-family: 'å¾®è»Ÿæ­£é»‘é«”'; }
  #pairCodeDisplay { position: fixed; top: 10px; left: 10px; background: #444; padding: 8px 12px; border-radius: 5px; font-weight: bold; user-select:none; }
  #matchInput, #matchBtn { position: fixed; top: 10px; left: 150px; padding: 5px 10px; font-size: 16px; border-radius: 5px; border: none; outline:none; }
  #matchInput { width: 120px; }
  #matchBtn { margin-left: 10px; cursor:pointer; background:#1a73e8; color:#fff; border:none; }
  canvas { display: block; margin: 0 auto; background: #fff; cursor: crosshair; border: 2px solid #555; }
  #copyright { position: fixed; bottom: 5px; width: 100%; text-align: center; font-size: 12px; color: #aaa; user-select:none; }
</style>
</head>
<body>

<div id="pairCodeDisplay">é…å°ç¢¼ï¼š<span id="myCode"></span></div>
<input id="matchInput" placeholder="è¼¸å…¥é…å°ç¢¼" maxlength="6" />
<button id="matchBtn">é…å°</button>

<canvas id="canvas" width="800" height="600"></canvas>
<div id="copyright">Â© FSpeter å‘‚ 2025æ‰€æœ‰</div>

<script>
  // Worker URL è¨­å®š
  const WORKER_URL = 'https://ä½ çš„workerç¶²å€.workers.dev';

  // éš¨æ©Ÿç”¢ç”Ÿ 6 ä½é…å°ç¢¼
  function generatePairCode(length = 6) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let code = '';
    for(let i=0; i<length; i++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
  }

  const myPairCode = generatePairCode();
  document.getElementById('myCode').textContent = myPairCode;

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // ç•«ç­†åƒæ•¸
  let drawing = false;
  let lastX = 0;
  let lastY = 0;

  // WebRTC è®Šæ•¸
  let pc;
  let dataChannel;

  // ç•«ç­†é¡è‰²è·Ÿç²—ç´°
  const penColor = '#000';
  const penSize = 2;

  // ç¹ªè£½ç·šæ¢
  function drawLine(x1, y1, x2, y2, color=penColor, size=penSize) {
    ctx.strokeStyle = color;
    ctx.lineWidth = size;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  // ç•«ç­†äº‹ä»¶
  canvas.addEventListener('mousedown', e => {
    drawing = true;
    lastX = e.offsetX;
    lastY = e.offsetY;
  });

  canvas.addEventListener('mouseup', e => {
    drawing = false;
  });

  canvas.addEventListener('mouseout', e => {
    drawing = false;
  });

  canvas.addEventListener('mousemove', e => {
    if (!drawing) return;
    drawLine(lastX, lastY, e.offsetX, e.offsetY);
    sendDrawData({x1: lastX, y1: lastY, x2: e.offsetX, y2: e.offsetY});
    lastX = e.offsetX;
    lastY = e.offsetY;
  });

  // å‚³é€ç•«ç­†è³‡æ–™çµ¦å°æ–¹
  function sendDrawData(data) {
    if (dataChannel && dataChannel.readyState === 'open') {
      dataChannel.send(JSON.stringify(data));
    }
  }

  // æ¥æ”¶ç•«ç­†è³‡æ–™
  function receiveDrawData(data) {
    const d = JSON.parse(data);
    drawLine(d.x1, d.y1, d.x2, d.y2);
  }

  // å»ºç«‹ WebRTC é€£ç·š
  async function createPeerConnection(isCaller, roomId) {
    pc = new RTCPeerConnection({
      iceServers: [{urls: "stun:stun.l.google.com:19302"}]
    });

    pc.onicecandidate = async event => {
      if (event.candidate === null) {
        // ICE candidate å‚³é€å®Œç•¢ï¼Œå„²å­˜ offer/answer åˆ° Worker KV
        const desc = pc.localDescription;
        await fetch(`${WORKER_URL}/${roomId}`, {
          method: 'POST',
          body: JSON.stringify(desc)
        });
      }
    };

    if (isCaller) {
      dataChannel = pc.createDataChannel('drawChannel');
      setupDataChannel();
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      // offer è³‡æ–™æœƒåœ¨ icecandidate null æ™‚å„²å­˜
    } else {
      pc.ondatachannel = event => {
        dataChannel = event.channel;
        setupDataChannel();
      };

      // æ‹¿å°æ–¹ offer
      let offerData;
      while(true) {
        await new Promise(r => setTimeout(r, 1000));
        offerData = await fetch(`${WORKER_URL}/${roomId}`).then(r => {
          if(r.status === 200) return r.json();
          else return null;
        });
        if (offerData) break;
      }
      await pc.setRemoteDescription(offerData);

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      // answer è³‡æ–™æœƒåœ¨ icecandidate null æ™‚å„²å­˜
    }

    // æ‹¿å°æ–¹çš„ answer/offer (écaller æ‹¿ answerï¼Œcaller ç­‰å¾… answer)
    if (isCaller) {
      let answerData;
      while(true) {
        await new Promise(r => setTimeout(r, 1000));
        answerData = await fetch(`${WORKER_URL}/${roomId}`).then(r => {
          if(r.status === 200) return r.json();
          else return null;
        });
        if(answerData && answerData.type === 'answer') {
          await pc.setRemoteDescription(answerData);
          break;
        }
      }
    }
  }

  function setupDataChannel() {
    dataChannel.onopen = () => {
      console.log('è³‡æ–™é€šé“é–‹å•Ÿ');
    };
    dataChannel.onmessage = e => {
      receiveDrawData(e.data);
    };
  }

  // é»é…å°æŒ‰éˆ•æ™‚å•Ÿå‹•é…å°
  document.getElementById('matchBtn').onclick = async () => {
    const inputCode = document.getElementById('matchInput').value.toUpperCase();
    if(!inputCode || inputCode.length !== 6) {
      alert('è«‹è¼¸å…¥6ç¢¼é…å°ç¢¼');
      return;
    }

    if(inputCode === myPairCode) {
      alert('ä¸èƒ½è·Ÿè‡ªå·±é…å°å•¦ï¼Œ);
      return;
    }

    // åˆ¤æ–·èª°å…ˆé–‹ offerï¼Œèª°å…ˆç•¶ answerï¼ˆä»¥å­—æ¯åºæ±ºå®šï¼‰
    if(myPairCode < inputCode) {
      // æˆ‘æ˜¯caller
      await createPeerConnection(true, myPairCode);
    } else {
      // æˆ‘æ˜¯answerer
      await createPeerConnection(false, inputCode);
    }
  };

</script>
</body>
</html>

