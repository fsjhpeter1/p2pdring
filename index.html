<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>ä¸‰æ¬¡å“¥çš„ç•«å¸ƒ</title>
  <style>
    canvas { border: 1px solid #000; display: block; margin-top: 10px; }
    .toolbar { margin-top: 10px; }
    .color-button { width: 24px; height: 24px; border: none; margin-right: 5px; cursor: pointer; }
  </style>
</head>
<body>
  <h2>ä¸‰æ¬¡å“¥çš„ç•«å¸ƒ ğŸ–Œï¸</h2>
  <input id="codeInput" placeholder="è¼¸å…¥é…å°ä»£ç¢¼">
  <button id="connectBtn">é€£æ¥</button>
  <p id="status"></p>

  <div class="toolbar">
    <button class="color-button" style="background-color: red;" data-color="red"></button>
    <button class="color-button" style="background-color: black;" data-color="black"></button>
    <button class="color-button" style="background-color: yellow;" data-color="yellow"></button>
    <button class="color-button" style="background-color: blue;" data-color="blue"></button>
    <button class="color-button" style="background-color: purple;" data-color="purple"></button>
    <button id="eraserBtn">æ©¡çš®æ“¦</button>
    <button id="undoBtn">å¾©åŸ</button>
    <button id="clearBtn">å…¨éƒ¨æ¸…é™¤</button>
  </div>

  <canvas id="canvas" width="800" height="600"></canvas>
  <footer>Â© FSpeter å‘‚ 2025æ‰€æœ‰</footer>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let drawing = false;
    let currentColor = 'black';
    let strokes = [];
    let undoneStrokes = [];
    let code = '';

    document.querySelectorAll('.color-button').forEach(btn => {
      btn.addEventListener('click', () => {
        currentColor = btn.getAttribute('data-color');
      });
    });

    document.getElementById('eraserBtn').addEventListener('click', () => {
      currentColor = 'white'; // å‡è¨­ç•«å¸ƒèƒŒæ™¯ç‚ºç™½è‰²
    });

    document.getElementById('undoBtn').addEventListener('click', () => {
      if (strokes.length > 0) {
        undoneStrokes.push(strokes.pop());
        redraw();
      }
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      strokes = [];
      undoneStrokes = [];
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    canvas.addEventListener('mousedown', (e) => {
      drawing = true;
      const pos = getMousePos(e);
      const stroke = { color: currentColor, points: [pos] };
      strokes.push(stroke);
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!drawing) return;
      const pos = getMousePos(e);
      const stroke = strokes[strokes.length - 1];
      stroke.points.push(pos);
      drawStroke(stroke);
    });

    canvas.addEventListener('mouseup', () => {
      drawing = false;
      if (code) {
        fetch('https://your-cloudflare-worker-url/save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code, strokes })
        });
      }
    });

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }

    function drawStroke(stroke) {
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      const points = stroke.points;
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.stroke();
    }

    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const stroke of strokes) {
        drawStroke(stroke);
      }
    }

    document.getElementById('connectBtn').addEventListener('click', () => {
      code = document.getElementById('codeInput').value.trim();
      if (!code) {
        alert('è«‹è¼¸å…¥é…å°ä»£ç¢¼');
        return;
      }

      fetch('https://your-cloudflare-worker-url/connect', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ code })
      })
      .then(response => response.json())
      .then(data => {
        document.getElementById('status').innerText = 'å·²é€£æ¥ï¼š' + code;
        startSync();
      })
      .catch(error => {
        console.error('é€£æ¥éŒ¯èª¤ï¼š', error);
      });
    });

    function startSync() {
      setInterval(() => {
        fetch(`https://your-cloudflare-worker-url/load?code=${code}`)
          .then(res => res.json())
          .then(serverStrokes => {
            if (JSON.stringify(serverStrokes) !== JSON.stringify(strokes)) {
              strokes = serverStrokes;
              redraw();
            }
          });
      }, 2000);
    }
  </script>
</body>
</html>
