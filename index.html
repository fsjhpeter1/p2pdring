<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>三次哥P2P畫板🔥</title>
<style>
  body, html { margin:0; padding:0; height:100%; overflow:hidden; background:#222; color:#eee; font-family: '微軟正黑體'; }
  #pairCodeDisplay { position: fixed; top: 10px; left: 10px; background: #444; padding: 8px 12px; border-radius: 5px; font-weight: bold; user-select:none; }
  #matchInput, #matchBtn { position: fixed; top: 10px; left: 150px; padding: 5px 10px; font-size: 16px; border-radius: 5px; border: none; outline:none; }
  #matchInput { width: 120px; }
  #matchBtn { margin-left: 10px; cursor:pointer; background:#1a73e8; color:#fff; border:none; }
  canvas { display: block; margin: 0 auto; background: #fff; cursor: crosshair; border: 2px solid #555; }
  #copyright { position: fixed; bottom: 5px; width: 100%; text-align: center; font-size: 12px; color: #aaa; user-select:none; }
</style>
</head>
<body>

<div id="pairCodeDisplay">配對碼：<span id="myCode"></span></div>
<input id="matchInput" placeholder="輸入配對碼" maxlength="6" />
<button id="matchBtn">配對</button>

<canvas id="canvas" width="800" height="600"></canvas>
<div id="copyright">© FSpeter 呂 2025所有</div>

<script>
  // Worker URL 設定
  const WORKER_URL = 'https://你的worker網址.workers.dev';

  // 隨機產生 6 位配對碼
  function generatePairCode(length = 6) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let code = '';
    for(let i=0; i<length; i++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
  }

  const myPairCode = generatePairCode();
  document.getElementById('myCode').textContent = myPairCode;

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // 畫筆參數
  let drawing = false;
  let lastX = 0;
  let lastY = 0;

  // WebRTC 變數
  let pc;
  let dataChannel;

  // 畫筆顏色跟粗細
  const penColor = '#000';
  const penSize = 2;

  // 繪製線條
  function drawLine(x1, y1, x2, y2, color=penColor, size=penSize) {
    ctx.strokeStyle = color;
    ctx.lineWidth = size;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  // 畫筆事件
  canvas.addEventListener('mousedown', e => {
    drawing = true;
    lastX = e.offsetX;
    lastY = e.offsetY;
  });

  canvas.addEventListener('mouseup', e => {
    drawing = false;
  });

  canvas.addEventListener('mouseout', e => {
    drawing = false;
  });

  canvas.addEventListener('mousemove', e => {
    if (!drawing) return;
    drawLine(lastX, lastY, e.offsetX, e.offsetY);
    sendDrawData({x1: lastX, y1: lastY, x2: e.offsetX, y2: e.offsetY});
    lastX = e.offsetX;
    lastY = e.offsetY;
  });

  // 傳送畫筆資料給對方
  function sendDrawData(data) {
    if (dataChannel && dataChannel.readyState === 'open') {
      dataChannel.send(JSON.stringify(data));
    }
  }

  // 接收畫筆資料
  function receiveDrawData(data) {
    const d = JSON.parse(data);
    drawLine(d.x1, d.y1, d.x2, d.y2);
  }

  // 建立 WebRTC 連線
  async function createPeerConnection(isCaller, roomId) {
    pc = new RTCPeerConnection({
      iceServers: [{urls: "stun:stun.l.google.com:19302"}]
    });

    pc.onicecandidate = async event => {
      if (event.candidate === null) {
        // ICE candidate 傳送完畢，儲存 offer/answer 到 Worker KV
        const desc = pc.localDescription;
        await fetch(`${WORKER_URL}/${roomId}`, {
          method: 'POST',
          body: JSON.stringify(desc)
        });
      }
    };

    if (isCaller) {
      dataChannel = pc.createDataChannel('drawChannel');
      setupDataChannel();
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      // offer 資料會在 icecandidate null 時儲存
    } else {
      pc.ondatachannel = event => {
        dataChannel = event.channel;
        setupDataChannel();
      };

      // 拿對方 offer
      let offerData;
      while(true) {
        await new Promise(r => setTimeout(r, 1000));
        offerData = await fetch(`${WORKER_URL}/${roomId}`).then(r => {
          if(r.status === 200) return r.json();
          else return null;
        });
        if (offerData) break;
      }
      await pc.setRemoteDescription(offerData);

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      // answer 資料會在 icecandidate null 時儲存
    }

    // 拿對方的 answer/offer (非caller 拿 answer，caller 等待 answer)
    if (isCaller) {
      let answerData;
      while(true) {
        await new Promise(r => setTimeout(r, 1000));
        answerData = await fetch(`${WORKER_URL}/${roomId}`).then(r => {
          if(r.status === 200) return r.json();
          else return null;
        });
        if(answerData && answerData.type === 'answer') {
          await pc.setRemoteDescription(answerData);
          break;
        }
      }
    }
  }

  function setupDataChannel() {
    dataChannel.onopen = () => {
      console.log('資料通道開啟');
    };
    dataChannel.onmessage = e => {
      receiveDrawData(e.data);
    };
  }

  // 點配對按鈕時啟動配對
  document.getElementById('matchBtn').onclick = async () => {
    const inputCode = document.getElementById('matchInput').value.toUpperCase();
    if(!inputCode || inputCode.length !== 6) {
      alert('請輸入6碼配對碼');
      return;
    }

    if(inputCode === myPairCode) {
      alert('不能跟自己配對啦，);
      return;
    }

    // 判斷誰先開 offer，誰先當 answer（以字母序決定）
    if(myPairCode < inputCode) {
      // 我是caller
      await createPeerConnection(true, myPairCode);
    } else {
      // 我是answerer
      await createPeerConnection(false, inputCode);
    }
  };

</script>
</body>
</html>

